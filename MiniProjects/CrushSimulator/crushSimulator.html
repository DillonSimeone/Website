<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Polygon Crush Simulator</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom CSS for the container */
        #container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        /* Style for the range inputs */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ef4444; /* red-500 */
            cursor: pointer;
            margin-top: -6px; /* Adjusting for border */
        }
        input[type=range] {
            accent-color: #ef4444; /* red-500 */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans h-screen overflow-hidden">

    <!-- Three.js Canvas Container -->
    <div id="container"></div>

    <!-- UI Overlay (Input and Status) -->
    <div class="fixed top-0 left-0 p-4 z-10 w-full flex flex-col sm:flex-row justify-between items-start space-y-4 sm:space-y-0">
        
        <!-- File Input and Randomize Button -->
        <div class="flex items-center space-x-4">
            <div class="bg-gray-800 p-3 rounded-lg shadow-xl flex items-center space-x-3">
                <label for="modelFile" class="text-sm font-medium">Load Model:</label>
                <input type="file" id="modelFile" accept=".gltf, .glb, .obj" class="text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-500 file:text-white hover:file:bg-indigo-600 transition-colors cursor-pointer">
            </div>
            <button id="randomizeButton" class="px-4 py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-xl shadow-lg transition-all active:scale-95">
                Random Model
            </button>
        </div>

        <!-- Crush Button and Info -->
        <div class="flex items-center space-x-4 bg-gray-800 p-3 rounded-lg shadow-xl">
            <button id="crushButton" class="px-6 py-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-xl shadow-lg transition-all active:scale-95 disabled:bg-gray-600 disabled:cursor-not-allowed" disabled>
                HOLD TO CRUSH
            </button>
            <div id="statusText" class="text-sm font-mono text-gray-400">
                Awaiting Model...
            </div>
        </div>
    </div>

    <!-- Control Panel -->
    <div id="controlPanel" class="fixed top-20 right-4 p-4 z-10 w-64 bg-gray-800 bg-opacity-90 rounded-xl shadow-2xl space-y-4">
        
        <!-- Crush Type Selection -->
        <h2 class="text-lg font-bold text-indigo-400 border-b border-gray-700 pb-2">Crush Type</h2>
        <select id="crushType" class="w-full bg-gray-700 border border-gray-600 text-white text-sm rounded-lg p-2.5 transition-colors">
            <option value="crushPoints">Crush Points (Localized)</option>
            <option value="allCrush">All Crush (Uniform)</option>
            <option value="scaledCrush">Scaled Crush (Axis)</option>
            <option value="twistCrush">Twist-Crush (Rotation)</option>
        </select>

        <!-- Crush Parameters -->
        <h2 id="crushParamHeader" class="text-lg font-bold text-indigo-400 border-b border-gray-700 pb-2 pt-4">Localized Parameters</h2>
        <div id="localizedParams" class="space-y-4">
            <div>
                <label for="numPoints" class="block text-sm font-medium">Crush Points: <span id="numPointsValue">5</span></label>
                <input type="range" id="numPoints" min="1" max="20" value="5" step="1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
            </div>
            <div>
                <label for="crushRadius" class="block text-sm font-medium">Radius: <span id="crushRadiusValue">2.0</span></label>
                <input type="range" id="crushRadius" min="0.1" max="5.0" value="2.0" step="0.1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
            </div>
            <div>
                <label for="falloffPower" class="block text-sm font-medium">Falloff Power: <span id="falloffPowerValue">2.0</span></label>
                <input type="range" id="falloffPower" min="1.0" max="5.0" value="2.0" step="0.1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
            </div>
        </div>
        
        <!-- Animation Type Controls -->
        <h2 class="text-lg font-bold text-indigo-400 border-b border-gray-700 pb-2 pt-4">Animation Type</h2>
        <select id="animSpeedType" class="w-full bg-gray-700 border border-gray-600 text-white text-sm rounded-lg p-2.5 transition-colors">
            <option value="smooth">Smooth</option>
            <option value="janky">Caving (Threshold)</option>
        </select>

        <!-- Smooth Speed Parameter (Visible for Smooth Type) -->
        <div id="smoothParams" class="space-y-4">
            <div>
                <label for="smoothCrushSpeed" class="block text-sm font-medium">Crush Speed: <span id="smoothCrushSpeedValue">0.5</span></label>
                <input type="range" id="smoothCrushSpeed" min="0.1" max="2.0" value="0.5" step="0.1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
            </div>
        </div>

        <!-- Caving Parameters (Visible for Caving Type) -->
        <div id="jankyParams" class="space-y-4 hidden">
            <h3 class="text-md font-medium text-gray-300">Caving Behavior</h3>
            <div>
                <label for="jerkRate" class="block text-sm font-medium">Caving Threshold (%): <span id="jerkRateValue">50</span></label>
                <input type="range" id="jerkRate" min="10" max="90" value="50" step="5" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
            </div>
            <div>
                <label for="jerkMagnitude" class="block text-sm font-medium">Caving Multiplier: <span id="jerkMagnitudeValue">3.0</span></label>
                <input type="range" id="jerkMagnitude" min="1.0" max="10.0" value="3.0" step="0.5" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
            </div>
        </div>
        
        <!-- Lighting Controls -->
        <h2 class="text-lg font-bold text-indigo-400 border-b border-gray-700 pb-2 pt-4">Lighting Controls</h2>
        
        <div class="flex items-center justify-between">
            <label for="lightColor" class="text-sm font-medium">Color:</label>
            <input type="color" id="lightColor" value="#ffffff" class="w-12 h-8 rounded-md cursor-pointer">
        </div>

        <div>
            <label for="lightIntensity" class="block text-sm font-medium">Intensity: <span id="lightIntensityValue">1.5</span></label>
            <input type="range" id="lightIntensity" min="0.1" max="5.0" value="1.5" step="0.1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
        </div>

        <div>
            <label for="lightAzimuth" class="block text-sm font-medium">Azimuth (Yaw): <span id="lightAzimuthValue">45째</span></label>
            <input type="range" id="lightAzimuth" min="0" max="360" value="45" step="1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
        </div>
        <div>
            <label for="lightElevation" class="block text-sm font-medium">Elevation (Pitch): <span id="lightElevationValue">45째</span></label>
            <input type="range" id="lightElevation" min="0" max="90" value="45" step="1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
        </div>

        <!-- Data Display -->
        <div class="pt-2 border-t border-gray-700">
            <h3 class="text-md font-bold text-gray-300">Live Data</h3>
            <p id="data-crush-progress" class="text-xs font-mono mt-1">Progress: 0.0%</p>
            <p id="data-vertex-count" class="text-xs font-mono">Vertices: 0</p>
            <p id="data-crush-type" class="text-xs font-mono">Type: Crush Points</p>
            <p id="data-anim-speed" class="text-xs font-mono">Type: Smooth</p>
        </div>
    </div>

    <!-- Loading Indicators -->
    <div id="loadingOverlay" class="fixed inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center z-20 hidden">
        <div class="text-center">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-500"></div>
            <p class="mt-4 text-white text-lg font-semibold">Loading Model...</p>
        </div>
    </div>

    <!-- Load Three.js and essential extensions -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>

    <script>
        // --- CORE THREE.JS SETUP ---
        let scene, camera, renderer, controls;
        let modelMesh = null;
        let originalPositions = null;
        let crushRandomFactors = null;
        let geometry = null;
        let directionalLight;
        let hemisphereLight; 

        // --- CRUSH MECHANISM PARAMETERS (GUI Controlled) ---
        let NUM_CRUSH_POINTS = 5;
        let CRUSH_RADIUS = 2.0;
        let FALLOFF_POWER = 2.0;
        let crushPoints = []; 
        let vertexToCrushPointDistances = null; 
        
        // --- ANIMATION JANKY/CAVING STATE ---
        let DEFAULT_CRUSH_SPEED = 0.5;
        let SMOOTH_CRUSH_SPEED = 0.5;

        let CAVING_THRESHOLD = 0.5;
        let CAVING_MULTIPLIER = 3.0;

        // --- DEFORMATION STATE ---
        let crushProgress = 0.0; 
        let isCrushing = false;
        const BASE_UNCRUSH_SPEED = 1.0; 
        const MAX_CRUSH = 0.9;
        
        let CURRENT_CRUSH_TYPE = 'crushPoints';
        let CURRENT_ANIM_SPEED = 'smooth';

        // --- RANDOM MODEL LIST (Simulating API) ---
        const RANDOM_MODEL_URLS = [
            'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb',
            'https://threejs.org/examples/models/gltf/DamagedHelmet/DamagedHelmet.glb',
            'https://threejs.org/examples/models/gltf/WaterBottle/WaterBottle.glb',
            'https://threejs.org/examples/models/gltf/LittlestTokyo/LittlestTokyo.glb',
            'https://threejs.org/examples/models/gltf/SheenChair/SheenChair.glb'
        ];

        // --- DOM Elements ---
        const crushButton = document.getElementById('crushButton');
        const randomizeButton = document.getElementById('randomizeButton');
        const fileInput = document.getElementById('modelFile');
        const statusText = document.getElementById('statusText');
        const loadingOverlay = document.getElementById('loadingOverlay');

        const crushTypeInput = document.getElementById('crushType');
        const animSpeedTypeInput = document.getElementById('animSpeedType');
        const localizedParamsDiv = document.getElementById('localizedParams');
        const smoothParamsDiv = document.getElementById('smoothParams');
        const jankyParamsDiv = document.getElementById('jankyParams');
        const crushParamHeader = document.getElementById('crushParamHeader');

        const numPointsInput = document.getElementById('numPoints');
        const crushRadiusInput = document.getElementById('crushRadius');
        const falloffPowerInput = document.getElementById('falloffPower');
        const numPointsValue = document.getElementById('numPointsValue');
        const crushRadiusValue = document.getElementById('crushRadiusValue');
        const falloffPowerValue = document.getElementById('falloffPowerValue');
        
        const smoothCrushSpeedInput = document.getElementById('smoothCrushSpeed');
        const smoothCrushSpeedValue = document.getElementById('smoothCrushSpeedValue');

        const jerkRateInput = document.getElementById('jerkRate'); // Caving Threshold
        const jerkMagnitudeInput = document.getElementById('jerkMagnitude'); // Caving Multiplier
        const jerkRateValue = document.getElementById('jerkRateValue');
        const jerkMagnitudeValue = document.getElementById('jerkMagnitudeValue');

        const dataCrushProgress = document.getElementById('data-crush-progress');
        const dataVertexCount = document.getElementById('data-vertex-count');
        const dataCrushType = document.getElementById('data-crush-type');
        const dataAnimSpeed = document.getElementById('data-anim-speed');

        const lightColorInput = document.getElementById('lightColor');
        const lightIntensityInput = document.getElementById('lightIntensity');
        const lightIntensityValue = document.getElementById('lightIntensityValue');
        const lightAzimuthInput = document.getElementById('lightAzimuth');
        const lightAzimuthValue = document.getElementById('lightAzimuthValue');
        const lightElevationInput = document.getElementById('lightElevation');
        const lightElevationValue = document.getElementById('lightElevationValue');


        // --- UTILITY: CRUSH DATA INITIALIZATION ---
        
        function reInitializeCrushData() {
            if (!geometry || !originalPositions) return;

            const positions = originalPositions;
            const vertexCount = positions.length / 3;
            
            // 1. Randomize General Crush Factors (Noise) 
            crushRandomFactors = new Float32Array(vertexCount);
            for (let i = 0; i < vertexCount; i++) {
                crushRandomFactors[i] = 0.5 + Math.random(); // Range: [0.5, 1.5]
            }

            // 2. Select Random Crush Points 
            crushPoints = [];
            for (let i = 0; i < NUM_CRUSH_POINTS; i++) {
                const randomIndex = Math.floor(Math.random() * vertexCount);
                const x = positions[randomIndex * 3];
                const y = positions[randomIndex * 3 + 1];
                const z = positions[randomIndex * 3 + 2];
                crushPoints.push(new THREE.Vector3(x, y, z));
            }
            
            // 3. Calculate Distance to Closest Crush Point for every vertex
            vertexToCrushPointDistances = new Float32Array(vertexCount);
            const tempVertex = new THREE.Vector3();

            for (let i = 0; i < vertexCount; i++) {
                tempVertex.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);
                
                let minDistanceSq = Infinity;
                
                for (const crushPoint of crushPoints) {
                    const distanceSq = tempVertex.distanceToSquared(crushPoint);
                    if (distanceSq < minDistanceSq) {
                        minDistanceSq = distanceSq;
                    }
                }
                vertexToCrushPointDistances[i] = Math.sqrt(minDistanceSq);
            }

            console.log(`Crush data re-initialized: ${NUM_CRUSH_POINTS} points set.`);
        }

        function initMeshDeformation(mesh) {
            // Find the first BufferGeometry in the loaded object
            let geometryObject = null;
            mesh.traverse(child => {
                if (child.isMesh && child.geometry.isBufferGeometry) {
                    geometryObject = child.geometry;
                }
            });
            
            if (!geometryObject) {
                console.error("No suitable BufferGeometry found in the loaded model.");
                statusText.textContent = 'Error: Model must contain BufferGeometry.';
                dataVertexCount.textContent = 'Vertices: 0';
                return false;
            }

            geometry = geometryObject;
            
            const positionsArray = geometry.attributes.position.array;
            originalPositions = new Float32Array(positionsArray.length);
            originalPositions.set(positionsArray);
            
            reInitializeCrushData();

            geometry.computeBoundingBox();
            geometry.computeBoundingSphere();
            dataVertexCount.textContent = `Vertices: ${positionsArray.length / 3}`;
            
            // Ensure model position is centered on the origin for deformation calculations
            mesh.position.set(0, 0, 0);
            
            // Recenter geometry on the origin (important for Twist-Crush)
            geometry.center();

            return true;
        }

        // --- DEFORMATION LOGIC (Runs every frame) ---

        function getCrushSpeed(deltaTime) {
            if (CURRENT_ANIM_SPEED === 'smooth') {
                return SMOOTH_CRUSH_SPEED * deltaTime;
            } 
            
            // Logic for 'janky' (Caving Threshold)
            const normalizedProgress = crushProgress / MAX_CRUSH;
            
            if (normalizedProgress < CAVING_THRESHOLD) {
                // Initial phase: Slow and steady deformation (10% of default speed)
                return (DEFAULT_CRUSH_SPEED * 0.1) * deltaTime;
            } else {
                // Caving phase: Sudden jerk/fast movement
                return DEFAULT_CRUSH_SPEED * CAVING_MULTIPLIER * deltaTime;
            }
        }

        function updateCrush(deltaTime) {
            let crushChange = 0;
            let uncrushComplete = false;
            let finalCrushFactor = 0;

            if (isCrushing) {
                crushChange = getCrushSpeed(deltaTime);
                crushProgress = Math.min(crushProgress + crushChange, MAX_CRUSH);
            } else if (crushProgress > 0.0) {
                // Uncrush phase is always smooth at the BASE_UNCRUSH_SPEED
                crushChange = BASE_UNCRUSH_SPEED * deltaTime;
                let newProgress = Math.max(crushProgress - crushChange, 0.0);
                
                if (crushProgress > 0.0 && newProgress <= 0.0) {
                    uncrushComplete = true;
                    newProgress = 0.0;
                }
                crushProgress = newProgress;
            } else {
                return;
            }

            if (uncrushComplete && modelMesh) {
                // Reset non-vertex transforms (scale and rotation) and randomize crush points
                modelMesh.scale.set(1, 1, 1);
                modelMesh.rotation.set(0, 0, 0);
                reInitializeCrushData(); 
            }

            if (!geometry || !originalPositions || !vertexToCrushPointDistances) return;
            
            const positions = geometry.attributes.position.array;
            
            // --- 1. APPLY DEFORMATION BASED ON CRUSH TYPE ---
            for (let i = 0; i < positions.length; i += 3) {
                const vertexIndex = i / 3;
                const originalX = originalPositions[i];
                const originalY = originalPositions[i + 1];
                const originalZ = originalPositions[i + 2];

                let falloff = 1.0; 
                
                // Calculate falloff for localized crush types
                if (CURRENT_CRUSH_TYPE === 'crushPoints' || CURRENT_CRUSH_TYPE === 'scaledCrush' || CURRENT_CRUSH_TYPE === 'twistCrush') {
                    const distance = vertexToCrushPointDistances[vertexIndex];
                    if (distance < CRUSH_RADIUS) {
                        const normalizedDistance = distance / CRUSH_RADIUS; 
                        falloff = 1.0 - Math.pow(normalizedDistance, FALLOFF_POWER);
                    } else {
                        falloff = 0.0;
                    }
                }
                
                // Combine progress, noise, and falloff
                const overallCrush = crushProgress * crushRandomFactors[vertexIndex];
                finalCrushFactor = overallCrush * falloff;
                
                // --- 2. APPLY CORE CRUSH (Lerp to zero) ---
                let newX = originalX * (1.0 - finalCrushFactor);
                let newY = originalY * (1.0 - finalCrushFactor);
                let newZ = originalZ * (1.0 - finalCrushFactor);

                // --- 3. APPLY SPECIAL CRUSH MODIFIERS ---
                if (CURRENT_CRUSH_TYPE === 'scaledCrush') {
                    // Vertically scale down the entire object mesh based on crush progress
                    const scaleFactorY = 1.0 - (crushProgress * 0.5); // Shrink up to 50%
                    newY = originalY * scaleFactorY;
                    
                } else if (CURRENT_CRUSH_TYPE === 'twistCrush') {
                    const maxRadius = geometry.boundingSphere.radius || 1;
                    const normalizedY = originalY / maxRadius; 
                    
                    // Twist factor: positive for top half, negative for bottom half
                    const twistMagnitude = crushProgress * 0.5; 
                    const twistAngle = twistMagnitude * -normalizedY; 

                    // Apply rotation matrix to the new (crushed) position
                    const currentPos = new THREE.Vector3(newX, newY, newZ);
                    currentPos.applyAxisAngle(new THREE.Vector3(0, 1, 0), twistAngle);
                    
                    newX = currentPos.x;
                    newY = currentPos.y;
                    newZ = currentPos.z;
                }
                
                // --- 4. COMMIT POSITIONS ---
                positions[i]     = newX;
                positions[i + 1] = newY;
                positions[i + 2] = newZ;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.computeVertexNormals();
            geometry.computeBoundingSphere();
        }

        // --- LIGHTING SETUP & CONTROL ---
        
        function setupLighting() {
            if (hemisphereLight) scene.remove(hemisphereLight);
            if (directionalLight) scene.remove(directionalLight);
            
            hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2);
            scene.add(hemisphereLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            scene.add(directionalLight);

            updateLightDirection(parseFloat(lightAzimuthInput.value), parseFloat(lightElevationInput.value));
            updateLightIntensity(parseFloat(lightIntensityInput.value));
            updateLightColor(lightColorInput.value);
        }

        function updateLightDirection(azimuthDeg, elevationDeg) {
            const azimuthRad = azimuthDeg * (Math.PI / 180);
            const elevationRad = elevationDeg * (Math.PI / 180);
            const distance = 5; 
            
            const x = distance * Math.cos(elevationRad) * Math.sin(azimuthRad);
            const y = distance * Math.sin(elevationRad);
            const z = distance * Math.cos(elevationRad) * Math.cos(azimuthRad);

            directionalLight.position.set(x, y, z);
            
            lightAzimuthValue.textContent = `${azimuthDeg}째`;
            lightElevationValue.textContent = `${elevationDeg}째`;
        }

        function updateLightIntensity(intensity) {
            directionalLight.intensity = intensity;
            lightIntensityValue.textContent = intensity.toFixed(1);
        }
        
        function updateLightColor(colorHex) {
            directionalLight.color.set(colorHex);
        }

        // --- THREE.JS INITIALIZATION & RUN LOOP ---

        window.onload = function () {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            camera.position.set(2, 2, 3);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 

            setupLighting();
            
            const planeGeometry = new THREE.PlaneGeometry(100, 100);
            const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            scene.add(plane);

            animate();
            setupEventListeners();
            
            // Load a random model on start
            loadRandomModel();
        };

        // --- MAIN ANIMATION LOOP ---
        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);

            const deltaTime = (time - lastTime) / 1000;
            lastTime = time;

            if (modelMesh) {
                updateCrush(deltaTime);
                dataCrushProgress.textContent = `Progress: ${(crushProgress / MAX_CRUSH * 100).toFixed(1)}%`;
            }
            
            controls.update();
            renderer.render(scene, camera);
        }

        // --- MODEL LOADING FUNCTIONS ---
        
        function loadRandomModel() {
            const randomIndex = Math.floor(Math.random() * RANDOM_MODEL_URLS.length);
            const modelUrl = RANDOM_MODEL_URLS[randomIndex];
            loadSource(modelUrl);
        }

        function loadSource(source) {
            loadingOverlay.classList.remove('hidden');

            // --- Cleanup ---
            if (modelMesh) {
                scene.remove(modelMesh);
                modelMesh.traverse(child => {
                    if (child.isMesh) {
                        child.geometry.dispose();
                        child.material.dispose();
                    }
                });
                modelMesh = null;
                geometry = null;
                crushProgress = 0.0;
            }

            let url;
            let fileName;
            let objectUrlToRevoke = null;

            if (source instanceof File) {
                url = URL.createObjectURL(source);
                fileName = source.name.toLowerCase();
                objectUrlToRevoke = url;
            } else if (typeof source === 'string') {
                url = source;
                const urlParts = source.split('/');
                fileName = urlParts[urlParts.length - 1].toLowerCase();
            } else {
                statusText.textContent = 'Error: Invalid model source.';
                loadingOverlay.classList.add('hidden');
                crushButton.disabled = true;
                return;
            }


            let loader;
            if (fileName.endsWith('.glb') || fileName.endsWith('.gltf')) {
                loader = new THREE.GLTFLoader();
            } else if (fileName.endsWith('.obj')) {
                loader = new THREE.OBJLoader();
            } else {
                statusText.textContent = `Error: Unsupported file type: ${fileName}`;
                loadingOverlay.classList.add('hidden');
                crushButton.disabled = true;
                if (objectUrlToRevoke) URL.revokeObjectURL(objectUrlToRevoke);
                return;
            }

            // High-contrast, shiny material for visibility
            const crushMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffa500, 
                specular: 0xffffff, 
                shininess: 50, 
                side: THREE.DoubleSide,
                flatShading: true 
            });


            loader.load(
                url,
                (loaded) => {
                    let mesh;
                    if (loaded.scene) { 
                        mesh = loaded.scene;
                        mesh.traverse((child) => {
                            if (child.isMesh) {
                                // Apply uniform crush material for consistent testing
                                child.material = crushMaterial;
                            }
                        });
                    } else if (loaded.type === 'Group' || loaded.type === 'Mesh') { 
                        mesh = loaded;
                        mesh.traverse((child) => {
                            if (child.isMesh) {
                                child.material = crushMaterial;
                            }
                        });
                    }

                    if (mesh) {
                        const success = initMeshDeformation(mesh);
                        
                        if (success) {
                            modelMesh = mesh;
                            if (geometry.boundingSphere) {
                                // Center on Y-axis for ground visibility
                                modelMesh.position.y = geometry.boundingSphere.radius;
                            } else {
                                modelMesh.position.y = 1; 
                            }
                            scene.add(modelMesh);
                            
                            crushButton.disabled = false;
                            statusText.textContent = `Model "${fileName}" loaded successfully.`;
                        } else {
                            statusText.textContent = 'Error: Geometry initialization failed.';
                            crushButton.disabled = true;
                        }
                    } else {
                         statusText.textContent = 'Error: Could not extract mesh from file.';
                         crushButton.disabled = true;
                    }

                    loadingOverlay.classList.add('hidden');
                    if (objectUrlToRevoke) URL.revokeObjectURL(objectUrlToRevoke);
                },
                (xhr) => {
                    const percent = Math.floor(xhr.loaded / xhr.total * 100);
                    statusText.textContent = `Loading: ${percent}%`;
                },
                (error) => {
                    // --- ERROR FIX: More descriptive error logging for network issues ---
                    console.error('An error happened during model loading:', error);
                    let errorMessage = `Failed to load model from ${url}.`;

                    if (error && error.type === 'error' && error.target && error.target.status === 0) {
                        errorMessage += ' This is often due to network issues, CORS policy, or the model URL being invalid.';
                    } else if (error && error.message) {
                        errorMessage += ` Reason: ${error.message}`;
                    }

                    statusText.textContent = `Error: ${errorMessage}`;
                    loadingOverlay.classList.add('hidden');
                    if (objectUrlToRevoke) URL.revokeObjectURL(objectUrlToRevoke);
                    crushButton.disabled = true;
                    // --- END ERROR FIX ---
                }
            );
        }

        // --- INPUT HANDLING ---

        function updateCrushGUI() {
            const isLocalized = CURRENT_CRUSH_TYPE !== 'allCrush';
            
            // Show/hide localized parameters
            localizedParamsDiv.classList.toggle('hidden', !isLocalized);
            
            // Update header based on crush type
            if (CURRENT_CRUSH_TYPE === 'crushPoints') {
                crushParamHeader.textContent = 'Localized Parameters';
            } else if (CURRENT_CRUSH_TYPE === 'scaledCrush') {
                crushParamHeader.textContent = 'Crush & Scale Params';
            } else if (CURRENT_CRUSH_TYPE === 'twistCrush') {
                crushParamHeader.textContent = 'Twist & Crush Params';
            } else if (CURRENT_CRUSH_TYPE === 'allCrush') {
                crushParamHeader.textContent = 'Uniform Crush (No Params)';
            }
            
            // Show/hide animation specific parameters
            const isSmooth = CURRENT_ANIM_SPEED === 'smooth';
            smoothParamsDiv.classList.toggle('hidden', !isSmooth);
            jankyParamsDiv.classList.toggle('hidden', isSmooth);
            
            // Update data display
            dataCrushType.textContent = `Type: ${crushTypeInput.options[crushTypeInput.selectedIndex].text}`;
            dataAnimSpeed.textContent = `Type: ${animSpeedTypeInput.options[animSpeedTypeInput.selectedIndex].text}`;
        }

        function setupEventListeners() {
            // Crush button listeners
            crushButton.addEventListener('mousedown', () => {
                if (modelMesh) isCrushing = true;
            });
            
            crushButton.addEventListener('mouseup', () => {
                isCrushing = false;
            });
            
            crushButton.addEventListener('mouseleave', () => {
                 isCrushing = false;
            });
            
            // --- CRUSH TYPE & ANIMATION TYPE LISTENERS ---
            crushTypeInput.addEventListener('change', (e) => {
                CURRENT_CRUSH_TYPE = e.target.value;
                updateCrushGUI();
                if (modelMesh) reInitializeCrushData();
            });

            animSpeedTypeInput.addEventListener('change', (e) => {
                CURRENT_ANIM_SPEED = e.target.value;
                updateCrushGUI();
            });

            // --- CRUSH GUI Slider Listeners ---
            numPointsInput.addEventListener('input', (e) => {
                NUM_CRUSH_POINTS = parseInt(e.target.value);
                numPointsValue.textContent = NUM_CRUSH_POINTS;
                if (modelMesh) reInitializeCrushData(); 
            });

            crushRadiusInput.addEventListener('input', (e) => {
                CRUSH_RADIUS = parseFloat(e.target.value);
                crushRadiusValue.textContent = CRUSH_RADIUS.toFixed(1);
            });

            falloffPowerInput.addEventListener('input', (e) => {
                FALLOFF_POWER = parseFloat(e.target.value);
                falloffPowerValue.textContent = FALLOFF_POWER.toFixed(1);
            });

            // --- SMOOTH SPEED PARAM LISTENER ---
            smoothCrushSpeedInput.addEventListener('input', (e) => {
                SMOOTH_CRUSH_SPEED = parseFloat(e.target.value);
                smoothCrushSpeedValue.textContent = SMOOTH_CRUSH_SPEED.toFixed(1);
            });


            // --- CAVING PARAM LISTENERS ---
            jerkRateInput.addEventListener('input', (e) => {
                // Caving Threshold (converted from percent to factor)
                CAVING_THRESHOLD = parseFloat(e.target.value) / 100;
                jerkRateValue.textContent = e.target.value;
            });

            jerkMagnitudeInput.addEventListener('input', (e) => {
                // Caving Multiplier
                CAVING_MULTIPLIER = parseFloat(e.target.value);
                jerkMagnitudeValue.textContent = CAVING_MULTIPLIER.toFixed(1);
            });

            // --- LIGHTING GUI Listeners ---
            lightColorInput.addEventListener('input', (e) => updateLightColor(e.target.value));
            lightIntensityInput.addEventListener('input', (e) => updateLightIntensity(parseFloat(e.target.value)));
            lightAzimuthInput.addEventListener('input', (e) => updateLightDirection(parseFloat(e.target.value), parseFloat(lightElevationInput.value)));
            lightElevationInput.addEventListener('input', (e) => updateLightDirection(parseFloat(lightAzimuthInput.value), parseFloat(e.target.value)));


            // File input listener (Upload)
            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) loadSource(file);
            });
            
            // Randomize button listener
            randomizeButton.addEventListener('click', loadRandomModel);
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Initial GUI state update
            updateCrushGUI();
        }
    </script>
</body>
</html>
