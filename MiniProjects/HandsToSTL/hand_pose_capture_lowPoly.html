<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Pose Capture to STL</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
        }
        .container {
            display: flex;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        .panel {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .camera-panel {
            flex: 1;
        }
        .preview-panel {
            flex: 1;
        }
        .controls {
            margin-bottom: 20px;
            text-align: center;
        }
        button {
            background: #4a90e2;
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 5px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
        }
        button:hover {
            background: #357abd;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .capture-btn {
            background: #e74c3c;
            font-size: 18px;
            padding: 15px 30px;
            font-weight: bold;
        }
        .capture-btn:hover {
            background: #c0392b;
        }
        #videoElement {
            width: 100%;
            height: 400px;
            border-radius: 10px;
            object-fit: cover;
        }
        #canvasElement {
            width: 100%;
            height: 400px;
            border-radius: 10px;
            background: #000;
        }
        #preview3D {
            width: 100%;
            height: 400px;
            border-radius: 10px;
            background: #000;
        }
        .status {
            text-align: center;
            margin-top: 10px;
            padding: 10px;
            border-radius: 5px;
            background: #333;
        }
        .hand-detected {
            background: #27ae60 !important;
        }
        .info {
            background: #34495e;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }
        h1 {
            text-align: center;
            color: #4a90e2;
            margin-bottom: 30px;
        }
        h2 {
            color: #e67e22;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <h1>üñêÔ∏è Hand Pose Capture to STL</h1>
    
    <div class="container">
        <div class="panel camera-panel">
            <h2>Camera Feed</h2>
            <div class="controls">
                <button id="startBtn">Start Camera</button>
                <button id="captureBtn" class="capture-btn" disabled>üì∏ Capture Hand (SPACE)</button>
            </div>
            <video id="videoElement" autoplay muted></video>
            <canvas id="canvasElement"></canvas>
            <div id="status" class="status">Camera not started</div>
        </div>

        <div class="panel preview-panel">
            <h2>3D Hand Model</h2>
            <div class="controls">
                <button id="downloadBtn" disabled>‚¨áÔ∏è Download STL</button>
                <button id="clearBtn">üóëÔ∏è Clear Model</button>
            </div>
            <div id="preview3D"></div>
            <div class="info">
                <h3>Instructions:</h3>
                <ul>
                    <li>Click "Start Camera" to begin hand tracking</li>
                    <li>Show your hand to the camera</li>
                    <li>Press SPACEBAR or click "Capture Hand" when ready</li>
                    <li>View the 3D model on the right</li>
                    <li>Download as STL for 3D printing</li>
                </ul>
                <p><strong>Tips:</strong> Good lighting and clear hand visibility work best!</p>
            </div>
        </div>
    </div>

    <script>
        let camera, hands, scene, renderer, handMesh, handGeometry;
        let isCapturing = false;
        let latestHandLandmarks = null;

        // Three.js setup
        function init3D() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            const camera3D = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            camera3D.position.set(0, 0, 2);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            const container = document.getElementById('preview3D');
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // Add orbit-like controls with mouse
            let isMouseDown = false;
            let mouseX = 0, mouseY = 0;
            let targetRotationX = 0, targetRotationY = 0;
            let rotationX = 0, rotationY = 0;

            renderer.domElement.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            document.addEventListener('mousemove', (e) => {
                if (!isMouseDown) return;
                
                targetRotationY += (e.clientX - mouseX) * 0.01;
                targetRotationX += (e.clientY - mouseY) * 0.01;
                
                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            document.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            function animate() {
                requestAnimationFrame(animate);
                
                // Smooth rotation
                rotationX += (targetRotationX - rotationX) * 0.1;
                rotationY += (targetRotationY - rotationY) * 0.1;
                
                if (handMesh) {
                    handMesh.rotation.x = rotationX;
                    handMesh.rotation.y = rotationY;
                }
                
                renderer.render(scene, camera3D);
            }
            animate();
        }

        // MediaPipe setup
        function initHandTracking() {
            hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandResults);
        }

        function onHandResults(results) {
            const canvas = document.getElementById('canvasElement');
            const ctx = canvas.getContext('2d');
            
            canvas.width = results.image.width;
            canvas.height = results.image.height;
            
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            
            const status = document.getElementById('status');
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                status.textContent = 'Hand detected - Ready to capture!';
                status.className = 'status hand-detected';
                document.getElementById('captureBtn').disabled = false;
                
                latestHandLandmarks = results.multiHandLandmarks[0];
                
                // Draw hand landmarks
                drawConnectors(ctx, results.multiHandLandmarks[0], HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                drawLandmarks(ctx, results.multiHandLandmarks[0], {color: '#FF0000', lineWidth: 2});
            } else {
                status.textContent = 'No hand detected';
                status.className = 'status';
                document.getElementById('captureBtn').disabled = true;
                latestHandLandmarks = null;
            }
            
            ctx.restore();
        }

        function create3DHandFromLandmarks(landmarks) {
            if (!landmarks || landmarks.length < 21) return;

            // Clear existing hand model
            if (handMesh) {
                scene.remove(handMesh);
            }

            // Scale and center the hand
            const scale = 2;
            let centerX = 0, centerY = 0, centerZ = 0;
            
            landmarks.forEach(landmark => {
                centerX += landmark.x;
                centerY += landmark.y;
                centerZ += landmark.z;
            });
            centerX /= landmarks.length;
            centerY /= landmarks.length;
            centerZ /= landmarks.length;

            // Convert landmarks to 3D coordinates
            const vertices = landmarks.map(landmark => ({
                x: (landmark.x - centerX) * scale,
                y: -(landmark.y - centerY) * scale,
                z: (landmark.z - centerZ) * scale * 2
            }));

            // Define finger segments with realistic widths
            const fingerSegments = [
                // Thumb (wider at base, narrower at tip)
                { start: 0, end: 1, startRadius: 0.08, endRadius: 0.07 },
                { start: 1, end: 2, startRadius: 0.07, endRadius: 0.06 },
                { start: 2, end: 3, startRadius: 0.06, endRadius: 0.05 },
                { start: 3, end: 4, startRadius: 0.05, endRadius: 0.04 },
                
                // Index finger
                { start: 5, end: 6, startRadius: 0.06, endRadius: 0.055 },
                { start: 6, end: 7, startRadius: 0.055, endRadius: 0.05 },
                { start: 7, end: 8, startRadius: 0.05, endRadius: 0.045 },
                
                // Middle finger (longest, slightly thicker)
                { start: 9, end: 10, startRadius: 0.065, endRadius: 0.06 },
                { start: 10, end: 11, startRadius: 0.06, endRadius: 0.055 },
                { start: 11, end: 12, startRadius: 0.055, endRadius: 0.05 },
                
                // Ring finger
                { start: 13, end: 14, startRadius: 0.06, endRadius: 0.055 },
                { start: 14, end: 15, startRadius: 0.055, endRadius: 0.05 },
                { start: 15, end: 16, startRadius: 0.05, endRadius: 0.045 },
                
                // Pinky (smallest)
                { start: 17, end: 18, startRadius: 0.05, endRadius: 0.045 },
                { start: 18, end: 19, startRadius: 0.045, endRadius: 0.04 },
                { start: 19, end: 20, startRadius: 0.04, endRadius: 0.035 },
                
                // Palm connections (thicker for palm structure)
                { start: 0, end: 5, startRadius: 0.08, endRadius: 0.07 },
                { start: 5, end: 9, startRadius: 0.07, endRadius: 0.07 },
                { start: 9, end: 13, startRadius: 0.07, endRadius: 0.07 },
                { start: 13, end: 17, startRadius: 0.07, endRadius: 0.06 },
                { start: 0, end: 17, startRadius: 0.08, endRadius: 0.06 }
            ];

            handGeometry = new THREE.BufferGeometry();
            const meshVertices = [];
            const meshIndices = [];
            let vertexIndex = 0;

            // Create realistic finger segments
            fingerSegments.forEach(segment => {
                const start = new THREE.Vector3(vertices[segment.start].x, vertices[segment.start].y, vertices[segment.start].z);
                const end = new THREE.Vector3(vertices[segment.end].x, vertices[segment.end].y, vertices[segment.end].z);
                
                // Create tapered cylinder (cone frustum) for more realistic finger shape
                const height = start.distanceTo(end);
                const cylinderGeometry = new THREE.CylinderGeometry(
                    segment.startRadius, // top radius (at start point)
                    segment.endRadius,   // bottom radius (at end point)
                    height,
                    12  // more segments for smoother cylinders
                );

                // Orient the cylinder along the bone direction
                const direction = new THREE.Vector3().subVectors(end, start).normalize();
                const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
                
                // Create a transformation matrix
                const matrix = new THREE.Matrix4();
                
                // Calculate rotation to align with bone direction
                const up = new THREE.Vector3(0, 1, 0);
                const quaternion = new THREE.Quaternion().setFromUnitVectors(up, direction);
                
                // Apply transformation using matrix
                matrix.makeRotationFromQuaternion(quaternion);
                matrix.setPosition(midpoint);
                cylinderGeometry.applyMatrix4(matrix);

                // Add to main geometry
                const cylinderVertices = cylinderGeometry.attributes.position.array;
                const cylinderIndices = cylinderGeometry.index ? cylinderGeometry.index.array : [];

                for (let i = 0; i < cylinderVertices.length; i += 3) {
                    meshVertices.push(cylinderVertices[i], cylinderVertices[i + 1], cylinderVertices[i + 2]);
                }

                if (cylinderIndices.length > 0) {
                    for (let i = 0; i < cylinderIndices.length; i += 3) {
                        meshIndices.push(
                            cylinderIndices[i] + vertexIndex,
                            cylinderIndices[i + 1] + vertexIndex,
                            cylinderIndices[i + 2] + vertexIndex
                        );
                    }
                }

                vertexIndex += cylinderVertices.length / 3;
            });

            // Add joints as slightly flattened spheres for more realistic knuckles
            const jointSizes = [
                0.08, // wrist (0)
                0.07, 0.06, 0.055, 0.05, // thumb (1-4)
                0.065, 0.06, 0.055, 0.05, // index (5-8)
                0.07, 0.065, 0.06, 0.055, // middle (9-12)
                0.065, 0.06, 0.055, 0.05, // ring (13-16)
                0.055, 0.05, 0.045, 0.04  // pinky (17-20)
            ];

            vertices.forEach((vertex, idx) => {
                // Create slightly flattened ellipsoid for joints
                const sphereGeometry = new THREE.SphereGeometry(jointSizes[idx], 10, 8);
                
                // Flatten slightly for more realistic knuckle shape
                sphereGeometry.scale(1, 0.8, 1);
                sphereGeometry.translate(vertex.x, vertex.y, vertex.z);

                const sphereVertices = sphereGeometry.attributes.position.array;
                const sphereIndices = sphereGeometry.index ? sphereGeometry.index.array : [];

                for (let i = 0; i < sphereVertices.length; i += 3) {
                    meshVertices.push(sphereVertices[i], sphereVertices[i + 1], sphereVertices[i + 2]);
                }

                if (sphereIndices.length > 0) {
                    for (let i = 0; i < sphereIndices.length; i += 3) {
                        meshIndices.push(
                            sphereIndices[i] + vertexIndex,
                            sphereIndices[i + 1] + vertexIndex,
                            sphereIndices[i + 2] + vertexIndex
                        );
                    }
                }

                vertexIndex += sphereVertices.length / 3;
            });

            // Create palm surface for more solid hand structure
            const palmIndices = [0, 5, 9, 13, 17]; // wrist to finger bases
            for (let i = 0; i < palmIndices.length - 1; i++) {
                const p1 = vertices[palmIndices[i]];
                const p2 = vertices[palmIndices[i + 1]];
                const p3 = vertices[0]; // connect back to wrist
                
                // Add palm triangle
                const startIdx = vertexIndex;
                meshVertices.push(p1.x, p1.y, p1.z);
                meshVertices.push(p2.x, p2.y, p2.z);
                meshVertices.push(p3.x, p3.y, p3.z);
                
                meshIndices.push(startIdx, startIdx + 1, startIdx + 2);
                vertexIndex += 3;
            }

            handGeometry.setIndex(meshIndices);
            handGeometry.setAttribute('position', new THREE.Float32BufferAttribute(meshVertices, 3));
            handGeometry.computeVertexNormals();

            const material = new THREE.MeshLambertMaterial({ 
                color: 0xfdbcb4, // More skin-like color
                wireframe: false
            });

            handMesh = new THREE.Mesh(handGeometry, material);
            scene.add(handMesh);

            document.getElementById('downloadBtn').disabled = false;
        }

        function downloadSTL() {
            if (!handGeometry) return;

            const vertices = handGeometry.attributes.position.array;
            const indices = handGeometry.index.array;

            let stlString = 'solid hand\n';

            for (let i = 0; i < indices.length; i += 3) {
                const i1 = indices[i] * 3;
                const i2 = indices[i + 1] * 3;
                const i3 = indices[i + 2] * 3;

                const v1 = new THREE.Vector3(vertices[i1], vertices[i1 + 1], vertices[i1 + 2]);
                const v2 = new THREE.Vector3(vertices[i2], vertices[i2 + 1], vertices[i2 + 2]);
                const v3 = new THREE.Vector3(vertices[i3], vertices[i3 + 1], vertices[i3 + 2]);

                const normal = new THREE.Vector3()
                    .crossVectors(
                        new THREE.Vector3().subVectors(v2, v1),
                        new THREE.Vector3().subVectors(v3, v1)
                    )
                    .normalize();

                stlString += `  facet normal ${normal.x} ${normal.y} ${normal.z}\n`;
                stlString += '    outer loop\n';
                stlString += `      vertex ${v1.x} ${v1.y} ${v1.z}\n`;
                stlString += `      vertex ${v2.x} ${v2.y} ${v2.z}\n`;
                stlString += `      vertex ${v3.x} ${v3.y} ${v3.z}\n`;
                stlString += '    endloop\n';
                stlString += '  endfacet\n';
            }

            stlString += 'endsolid hand\n';

            const blob = new Blob([stlString], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `hand_pose_${new Date().getTime()}.stl`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 640, height: 480 } 
                });
                
                const video = document.getElementById('videoElement');
                video.srcObject = stream;
                
                camera = new Camera(video, {
                    onFrame: async () => {
                        await hands.send({ image: video });
                    },
                    width: 640,
                    height: 480
                });
                camera.start();
                
                document.getElementById('startBtn').disabled = true;
                document.getElementById('status').textContent = 'Camera started - Show your hand!';
            } catch (error) {
                alert('Could not access camera: ' + error.message);
            }
        });

        document.getElementById('captureBtn').addEventListener('click', () => {
            if (latestHandLandmarks) {
                create3DHandFromLandmarks(latestHandLandmarks);
            }
        });

        document.getElementById('downloadBtn').addEventListener('click', downloadSTL);

        document.getElementById('clearBtn').addEventListener('click', () => {
            if (handMesh) {
                scene.remove(handMesh);
                handMesh = null;
                handGeometry = null;
                document.getElementById('downloadBtn').disabled = true;
            }
        });

        // Keyboard shortcut
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space' && latestHandLandmarks) {
                event.preventDefault();
                create3DHandFromLandmarks(latestHandLandmarks);
            }
        });

        // Initialize
        init3D();
        initHandTracking();
    </script>
</body>
</html>