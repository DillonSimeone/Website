<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LVGL C-Array Visualizer</title>
    <script src="assets/js/tailwindcss.js"></script>
    <link href="assets/css/inter-font.css" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #1f2937; color: #f3f4f6; }
        #drop-zone {
            border: 3px dashed #6b7280;
            padding: 3rem;
            text-align: center;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        #drop-zone.drag-over {
            border-color: #3b82f6;
            background-color: #111827;
        }
        canvas {
            background-color: #000000;
            border: 4px solid #4b5563;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
            margin-top: 1.5rem;
        }
    </style>
</head>
<body class="p-8 min-h-screen">

    <div class="max-w-4xl mx-auto">
        <h1 class="text-3xl font-bold mb-6 text-center text-blue-400">LVGL C-Array Image Visualizer</h1>
        <p class="text-center text-gray-300 mb-8">Drag and drop your LVGL-generated `.c` file here to view the raw pixel data.</p>

        <div id="drop-zone" class="bg-gray-800 hover:bg-gray-700">
            <p class="text-xl font-semibold text-gray-400">Drop LVGL C Array File Here</p>
            <p class="text-sm text-gray-500 mt-2">(Supports: `LV_IMG_CF_INDEXED_2BIT`, `LV_IMG_CF_INDEXED_4BIT`, and <span class="text-yellow-400">`LV_IMG_CF_INDEXED_8BIT`</span>)</p>
        </div>

        <div id="image-container" class="mt-8 text-center hidden">
            <h2 class="text-2xl font-semibold mb-4 text-gray-200">Rendered Image: <span id="img-title" class="text-blue-400"></span></h2>
            <p id="img-meta" class="text-sm text-gray-400 mb-4"></p>
            <canvas id="image-canvas" class="mx-auto"></canvas>
            
            <div id="palette-info" class="mt-6 p-4 bg-gray-800 rounded-lg shadow-inner text-left">
                <h3 class="text-lg font-semibold text-gray-300 mb-2">Color Palette Used:</h3>
                <div id="palette-swatches" class="flex flex-wrap gap-4"></div>
            </div>
            
        </div>

        <div id="error-message" class="mt-8 p-4 bg-red-800 text-white rounded-lg hidden">
            <p class="font-bold">Error:</p>
            <p id="error-text"></p>
        </div>
    </div>

    <script>
        // --- Utility Functions for LVGL Data Parsing ---

        function hexToRgb(hex) {
            // Converts 0xAARRGGBB hex to standard RGB or RGBA string
            const alpha = (hex >> 24) & 0xFF;
            const r = (hex >> 16) & 0xFF;
            const g = (hex >> 8) & 0xFF;
            const b = hex & 0xFF;
            // LVGL often handles transparency, but for visualization, we'll use a simple fallback
            return `rgb(${r}, ${g}, ${b})`; 
        }

        function extractLVGLMetadata(cContent) {
            const result = {};
            const regexes = {
                w: /\.header\.w\s*=\s*(\d+)/,
                h: /\.header\.h\s*=\s*(\d+)/,
                cf: /\.header\.cf\s*=\s*([A-Z0-9_]+)/,
                mapName: /uint8_t\s+([a-zA-Z0-9_]+_map)\s*\[\]/,
                descriptorName: /const\s+lv_img_dsc_t\s+([a-zA-Z0-9_]+)\s*=/
            };

            // Extract main values
            result.w = parseInt(cContent.match(regexes.w)?.[1] || 0);
            result.h = parseInt(cContent.match(regexes.h)?.[1] || 0);
            result.cf = cContent.match(regexes.cf)?.[1] || 'UNKNOWN';
            
            // Extract the data array name
            const mapName = cContent.match(regexes.mapName)?.[1];
            result.name = cContent.match(regexes.descriptorName)?.[1] || (mapName ? mapName.replace('_map', '') : 'Untitled Image');

            // Extract raw hex values
            if (mapName) {
                const mapRegex = new RegExp(`const\\s+.*?uint8_t\\s+${mapName}\\s*\\[\\]\\s*=\\s*{([\\s\\S]*?)}`, 'm');
                const match = cContent.match(mapRegex);
                if (match) {
                    let hexData = match[1];
                    // Clean up comments and extract hex values
                    hexData = hexData.replace(/\/\*[\s\S]*?\*\//g, ''); 
                    // Match 0x followed by one or more hex characters
                    result.hexValues = hexData.match(/0x[0-9a-fA-F]+/g) || [];
                }
            }
            
            if (result.w === 0 || result.h === 0 || result.hexValues.length === 0) {
                throw new Error("Could not extract image dimensions, format, or pixel data from the file.");
            }
            
            return result;
        }

        function parseHexArrayToBytes(hexValues) {
            // Converts the array of "0xHH" strings into a Uint8Array
            const bytes = new Uint8Array(hexValues.length);
            for (let i = 0; i < hexValues.length; i++) {
                bytes[i] = parseInt(hexValues[i], 16);
            }
            return bytes;
        }

        // --- Core Rendering Functions ---
        
        // Corrected Core Rendering Function (Simplified and Robust)
        function renderLVGLImage(metadata, bytes) {
            const canvas = document.getElementById('image-canvas');
            const ctx = canvas.getContext('2d');
            const w = metadata.w;
            const h = metadata.h;
            const cf = metadata.cf;

            let bitDepth;
            
            // Determine bit depth from the LVGL format constant
            if (cf.includes('2BIT')) {
                bitDepth = 2;
            } else if (cf.includes('4BIT')) {
                bitDepth = 4;
            } else if (cf.includes('8BIT')) {
                bitDepth = 8;
            } else {
                document.getElementById('error-text').textContent = `Unsupported format: ${cf}. This tool supports only INDEXED_2BIT, INDEXED_4BIT, and INDEXED_8BIT.`;
                document.getElementById('error-message').classList.remove('hidden');
                document.getElementById('image-container').classList.add('hidden');
                return;
            }

            const paletteSize = Math.pow(2, bitDepth);
            const paletteDataSize = paletteSize * 4; // 4 bytes (AARRGGBB) per color

            if (bytes.length < paletteDataSize) {
                document.getElementById('error-text').textContent = `Data too short for ${cf}. Expected at least ${paletteDataSize} bytes for palette.`;
                document.getElementById('error-message').classList.remove('hidden');
                document.getElementById('image-container').classList.add('hidden');
                return;
            }

            // 1. Extract the Palette (AARRGGBB format)
            const palette = [];
            const paletteView = new DataView(bytes.buffer, 0, paletteDataSize);
            for (let i = 0; i < paletteSize; i++) {
                // Read 32-bit color (AARRGGBB), assuming Big Endian (false) is safe for this context
                palette.push(paletteView.getUint32(i * 4, false)); 
            }

            // Display palette swatches
            const swatchesContainer = document.getElementById('palette-swatches');
            swatchesContainer.innerHTML = '';
            palette.forEach((colorHex, index) => {
                const r = (colorHex >> 16) & 0xFF;
                const g = (colorHex >> 8) & 0xFF;
                const b = colorHex & 0xFF;
                // Use a standard RGB color for display (ignoring LVGL's alpha in AARRGGBB for simplicity)
                const hex = '#' + ((1 << 24) + r * 0x10000 + g * 0x100 + b).toString(16).slice(1).toUpperCase();

                const swatch = document.createElement('div');
                swatch.className = 'w-16 h-16 rounded-lg shadow-md border-2 border-gray-600 flex items-center justify-center text-xs font-mono';
                swatch.style.backgroundColor = hex;
                swatch.style.color = (r * 0.299 + g * 0.587 + b * 0.114) > 186 ? '#000' : '#fff'; // Contrast text
                swatch.title = `Index ${index}: ${hex}`;
                swatch.textContent = `Idx ${index}`;
                swatchesContainer.appendChild(swatch);
            });


            // 2. Render the Pixel Data
            const scaledW = w * 2;
            const scaledH = h * 2;
            canvas.width = scaledW;
            canvas.height = scaledH;
            ctx.imageSmoothingEnabled = false;

            // Create an off-screen canvas for the true resolution image data
            const offScreenCanvas = document.createElement('canvas');
            offScreenCanvas.width = w;
            offScreenCanvas.height = h;
            const offScreenCtx = offScreenCanvas.getContext('2d');
            const imageData = offScreenCtx.createImageData(w, h);
            const pixelData = imageData.data;
            
            let byteIndex = paletteDataSize; // Start reading pixel bytes after the palette
            const pixelsPerByte = 8 / bitDepth; // 4 for 2BIT, 2 for 4BIT, 1 for 8BIT
            let totalPixelsRendered = 0;

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    let colorIndex = 0;
                    
                    if (bitDepth === 8) {
                        // 8BIT: 1 pixel per byte
                        byteIndex++;
                        if (byteIndex > bytes.length) break;
                        colorIndex = bytes[byteIndex - 1];

                    } else {
                        // 2BIT or 4BIT: Multiple pixels per byte
                        if (totalPixelsRendered % pixelsPerByte === 0) {
                            byteIndex++;
                            if (byteIndex > bytes.length) break; 
                        }
                        
                        const currentByte = bytes[byteIndex - 1]; 
                        
                        // Determine which index (0, 1, 2, 3) within the byte this pixel is
                        const indexInByte = x % pixelsPerByte;
                        
                        // Calculate shift based on Big Endian style (0-index is MSB, which is standard LVGL)
                        const shift = (pixelsPerByte - 1 - indexInByte) * bitDepth; 
                        
                        // Extract the color index
                        colorIndex = (currentByte >> shift) & ((1 << bitDepth) - 1);
                    }
                    
                    const colorHex = palette[colorIndex];
                    
                    // Set the pixel data on the off-screen canvas
                    const imgDataIndex = totalPixelsRendered * 4;
                    
                    // AARRGGBB -> R, G, B, A
                    pixelData[imgDataIndex] = (colorHex >> 16) & 0xFF; // R
                    pixelData[imgDataIndex + 1] = (colorHex >> 8) & 0xFF; // G
                    pixelData[imgDataIndex + 2] = colorHex & 0xFF; // B
                    pixelData[imgDataIndex + 3] = ((colorHex >> 24) & 0xFF) > 0 ? 255 : 255; // Alpha (set opaque if not transparent)
                    
                    totalPixelsRendered++;
                }
            }

            offScreenCtx.putImageData(imageData, 0, 0);
            
            // Draw the off-screen image onto the main canvas at 2x scale
            ctx.drawImage(offScreenCanvas, 0, 0, w, h, 0, 0, scaledW, scaledH);
        }


        // --- Event Handlers and Main Logic ---

        document.addEventListener('DOMContentLoaded', () => {
            const dropZone = document.getElementById('drop-zone');
            const errorText = document.getElementById('error-text');
            const errorMessage = document.getElementById('error-message');
            const imageContainer = document.getElementById('image-container');

            function displayError(message) {
                errorMessage.classList.remove('hidden');
                errorText.textContent = message;
                imageContainer.classList.add('hidden');
            }

            function handleFile(file) {
                errorMessage.classList.add('hidden');
                errorText.textContent = '';

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const cContent = event.target.result;
                        const metadata = extractLVGLMetadata(cContent);
                        const rawBytes = parseHexArrayToBytes(metadata.hexValues);
                        
                        document.getElementById('img-title').textContent = metadata.name;
                        document.getElementById('img-meta').textContent = 
                            `Dimensions: ${metadata.w}x${metadata.h} | Format: ${metadata.cf} | Total Bytes: ${rawBytes.length}`;

                        renderLVGLImage(metadata, rawBytes);

                        imageContainer.classList.remove('hidden');

                    } catch (e) {
                        displayError(`Parsing Error: ${e.message}`);
                        console.error("Full Parsing Error:", e);
                    }
                };
                reader.onerror = () => displayError('Failed to read file.');
                reader.readAsText(file);
            }

            // Prevent default drag behaviors
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, false);
            });

            // Highlight drop zone when item is over it
            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => dropZone.classList.add('drag-over'), false);
            });
            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => dropZone.classList.remove('drag-over'), false);
            });

            // Handle dropped files
            dropZone.addEventListener('drop', (e) => {
                const dt = e.dataTransfer;
                if (dt.files.length) {
                    handleFile(dt.files[0]);
                }
            }, false);

            // Also support traditional file input (for environments where drag-drop is tricky)
            dropZone.addEventListener('click', () => {
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.c';
                fileInput.onchange = (e) => {
                    if (e.target.files.length) {
                        handleFile(e.target.files[0]);
                    }
                };
                fileInput.click();
            });
        });
    </script>
</body>
</html>