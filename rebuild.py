import http.server
import socketserver
import webbrowser
import json
import os
import re
import sys

PORT = 8085

def get_svg_data_from_string(content):
    content = content.replace('\n', '')
    width_match = re.search(r'width="(\d+)"', content)
    height_match = re.search(r'height="(\d+)"', content)
    width = width_match.group(1) if width_match else "1920"
    height = height_match.group(1) if height_match else "1080"
    viewbox = f"0 0 {width} {height}"
    
    clean_content = re.sub(r'width="\d+"', '', content)
    clean_content = re.sub(r'height="\d+"', '', clean_content)
    
    if 'viewBox' not in clean_content:
        clean_content = clean_content.replace('<svg', f'<svg viewBox="{viewbox}" preserveAspectRatio="xMidYMid slice" style="width:100vw; height:100vh; position:fixed; top:0; left:0;"')
    
    return clean_content.replace('"', '\\"')

class GeneratorHandler(http.server.SimpleHTTPRequestHandler):
    def log_message(self, format, *args):
        return # Silent

    def do_POST(self):
        if self.path == '/save':
            content_length = int(self.headers['Content-Length'])
            post_data = self.rfile.read(content_length)
            data = json.loads(post_data)
            
            # Save raw SVGs just in case
            with open('bg-desktop.svg', 'w', encoding='utf-8') as f:
                f.write(data['desktop'])
            with open('bg-mobile.svg', 'w', encoding='utf-8') as f:
                f.write(data['mobile'])
            
            # Process for JS injection
            desktop_clean = get_svg_data_from_string(data['desktop'])
            mobile_clean = get_svg_data_from_string(data['mobile'])
            
            # Rebuild background.js
            rebuild_js(desktop_clean, mobile_clean)
            
            self.send_response(200)
            self.end_headers()
            self.wfile.write(b"OK")
            
            print("\n[âœ”] Background regenerated and injected successfully!")
            # Shutdown server after work is done
            os._exit(0)

def rebuild_js(desktop_svg, mobile_svg):
    template = """/* 
  Static Asset Background - Optimized for zero-computation rendering.
  Auto-generated by build_background tool.
*/

const desktopSVGData = "{{DESKTOP_SVG}}";
const mobileSVGData = "{{MOBILE_SVG}}";

const min = 20;
const max = 80;

window.mobilecheck = function() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
};

function draw() {
    const container = document.querySelector('.trianglify');
    if (!container) return;

    const isMobile = window.innerWidth < 800;
    const svgData = isMobile ? mobileSVGData : desktopSVGData;

    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = svgData;
    const pattern = tempDiv.querySelector('svg');
    if (!pattern) return;

    pattern.setAttribute('width', '100%');
    pattern.setAttribute('height', '100%');
    pattern.setAttribute('preserveAspectRatio', 'xMidYMid slice');

    const paths = Array.from(pattern.querySelectorAll('path'));
    paths.forEach(path => {
        if (typeof randomRgb === 'function') {
            const color = randomRgb(min, max);
            path.setAttribute('fill', color);
            path.setAttribute('stroke', color);
        }
    });

    const circleElement = document.createElement("div");
    circleElement.className = "circle";
    container.innerHTML = "";
    container.appendChild(pattern);
    container.appendChild(circleElement);

    const circle = document.querySelector('.circle');
    const polyPoints = paths.map(poly => {
        poly.classList.add('poly', 'fade');
        const rect = poly.getBoundingClientRect();
        return { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
    });

    document.removeEventListener('mousemove', document.fn);
    let ticking = false;
    let frameCount = 0;
    const polyActiveStates = new Array(polyPoints.length).fill(false);

    document.addEventListener('mousemove', document.fn = function fn(e) {
        if (!ticking) {
            window.requestAnimationFrame(() => {
                frameCount++;
                if (frameCount % 2 !== 0) { ticking = false; return; }
                const currentCircle = document.querySelector('.circle');
                if (!currentCircle) { ticking = false; return; }
                const radius = currentCircle.clientWidth / 2;
                const center = { x: e.clientX, y: e.clientY };
                currentCircle.style.transform = `translate(${center.x - radius}px, ${center.y - radius}px)`;
                for (let i = 0; i < polyPoints.length; i++) {
                    const isInCircle = detectPointInCircle(polyPoints[i], radius, center);
                    if (isInCircle && !polyActiveStates[i]) {
                        paths[i].classList.remove('fade');
                        polyActiveStates[i] = true;
                    } else if (!isInCircle && polyActiveStates[i]) {
                        paths[i].classList.add('fade');
                        polyActiveStates[i] = false;
                    }
                }
                ticking = false;
            });
            ticking = true;
        }
    });
}

function detectPointInCircle(point, radius, center) {
    return Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2) <= radius * radius;
}

if (document.readyState === 'loading') {
    window.addEventListener('DOMContentLoaded', draw);
} else {
    draw();
}
"""
    final_content = template.replace("{{DESKTOP_SVG}}", desktop_svg).replace("{{MOBILE_SVG}}", mobile_svg)
    with open('background.js', 'w', encoding='utf-8') as f:
        f.write(final_content)

if __name__ == "__main__":
    print(f"Starting Background Rebuild Server on port {PORT}...")
    print("Opening browser to generate fresh patterns...")
    
    with socketserver.TCPServer(("", PORT), GeneratorHandler) as httpd:
        webbrowser.open(f"http://localhost:{PORT}/generator.html")
        httpd.serve_forever()
